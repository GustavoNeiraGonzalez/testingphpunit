paso 1:

instalamos phpunit en nuestra carpeta para programar en php 
composer require phpunit/phpunit --dev

-----------------

paso 2:

en nuestro archivo creado por phpunit "composer.json" se agrega: 
    "autoload":{
        "classmap": [
            "src/"
        ]
    },
donde "src/" indica la carpceta donde estara el codigo php (por lo que no neceseriamente se puede llamara src 
siempre), y asi facilitamos el no importar las clases para usarlas en nuestros tests

ejecutar en consola:
composer dump-autoload -o
------------------

paso 3:

aqui creamos una carpeta en el directorio principal es decir ni en src ni en vendor (de phpunit)
preferiblemente llamada tests, en esta carpeta creariamos un archivo con algun 
nombre pero que termine en: ----->         Test          <---------
no Tests (PORQUE DARIA ERROR de que no ejecutaran los tests) por ejemplo OperationsTest.php ->EST
O NO

entonces dentro del archivo quedaria algo asi:
<?php
use PHPUnit\Framework\TestCase;

class OperationsTest extends TestCase{
    private $op;

    //funcion de phpunit para inicializar objetos que requeriremos 
    //en los tests donde new Testing indica el archivo de src Testing

    public function setUp():void{
        $this->op = new Testing();
    }
    
    //aqui la funcion de phpunit assertEquals busca que el valor sea 7
    //despues de la coma se busca la funcion sum que creamos anteriormente
    //la cual sumara valores

    public function testSumWithTwoValues(){
        $this->assertEquals(7, $this->op->sum(2,5));
    }
}
?>
la funcion que ya ejecutara los testing son testSumWithTwoValues
recordar crear nombres descriptivos para este tipo de funciones para tener una idea sin ver otro codigo
-------------------

paso 4:

ejecutar el comando para ejecutar los testing y aqui indicará si se ejecutó correctamente o dio error.
 ./vendor/bin/phpunit tests

----------------------------

valores no esperados y nulos

    //Verificar suma con valores nulos (no da error por valor nulo Y si esperas
    //un valor numerico dará error de numero no esperado, lo cual es erroneo,
    //y si esperas un valor nulo, dara un ok si das 2 valores nulos)
    //por lo que se debe arreglar dentro de la funcion sum

    public function testSumWithNullValues(){
        $this->assertEquals(NULL, $this->op->sum(NUll,NULL));
    }

-------------------

mocks:
una funcionalidad para controlar funciones de las que no tienes control,
por ejemplo tienes un metodo para encontrar la temperatura pero esta temperatura
devuelve la temperatura actual, y para las pruebas no solo te sirve esa
temperatura en especifico, entonces con un mock lo que haras es que usas 
ese metodo y devuelves lo que tu quieres que devuelva especificamente


TAMBIEN AYUDA A LA RAPIDEZ DEL TESTING, PORQUE SI POR ALGUNA RAZON 
LLAMAS A UNA API EXTERNA REALMENTE NO LA USAS,PORQUE TU BUSCAS EL RESULTADO ESPECIFICO
QUE NECESITAS PARA LOS TESTS.

EJEMPLO USANDO LA FUNCION SUM (SUMAR):
  public function testMockSum()
    {
        // Crear un mock para la clase Calculator
        $mock = $this->getMockBuilder(Testing::class) 
                     ->getMock();

        // Definir el comportamiento esperado del mock
        $mock->expects($this->once())
             ->method('sum')
             ->with(2, 3)
             ->willReturn(5);

        // Utilizar el mock en lugar de la instancia real
        $result = $mock->sum(2, 3);

        // Verificar que el resultado sea 5 usando el mock (result)
        $this->assertEquals(5, $result);
    
    }

-recordar que Testing:class se refiere a la clase que vas a usar, en este caso
Testing es la clase donde tengo guardada la funcion sum.

--------------------------------------------------------------------
la programacion del testing se basa

esperar resultados especificos de las funciones

acortar las funciones de prueba con los data providers. 

El manejo de excepciones,

 ¿Bases de datos ficticios? 

Y pruebas en base al rendimiento de la app?
